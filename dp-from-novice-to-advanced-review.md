---
title: "动态规划从新手到高级笔记"
date: 2021-09-01T16:33:29+08:00
draft: false
---


## 起因

本文是我阅读[ dynamic programming: from novice to advanced ](https://www.topcoder.com/thrive/articles/Dynamic%20Programming:%20From%20Novice%20to%20Advanced)的笔记，夹叙夹议。

## 初学等级
动态规划算法由递归公式和一个（或者几个）初始状态组成。他的子问题的答案是由之前已经解决的答案组成。一般是多项式复杂度，比回溯或者暴力算法要快。

第一个问题是，有 N 个硬币，币值是\\(V_1\\),\\(V_2\\)...\\(V_n\\)。要求找到最少的硬币，组成一个和`S`。或者不能组成，输出错误。

这个问题的“状态”定义是，如果我们想找到一个和 i, 首先必须找到比 i 小的所有的和的解法。

状态转移的方式是，对于每一个硬币\\(V_c\\)，和之前所有比 i 小的和相加，如果和是 i + 1，并且硬币个数最少，那我们就找到了 i + 1 的最优解。从而让状态从 i 转移到 i + 1。

原文在此有一个实际的例子。

还有一个不同的角度的计算方式。就是多轮更新最优解 \\(S_i\\)，我们用每一个硬币和现有的 \\(S_i\\) 相加，然后对比硬币的个数，如果个数更少，则更新新的 \\(S_s\\) 的结果。

这个解法和之前的本质相同，就是我们需要把硬币和现有和做一个双层循环比较，从而更新最优解。第一种是先 for 循环和，再 for 循环硬币，第二种是先 for 循环硬币，再 for 循环和。

---

这个问题我们可以用 Knuth 那个思路再深入一点，看看问题最优解的框架是什么样子。当你已经有了一个最优解S的时候（但没有比 S 小的其他和的最优解），如果此时题目变化了，要求和变成 S+N。应该如何变化。

也就是说我们使用的状态比 dp 方式信息少一些的时候，有没有可能构造出来状态转移方程。

我们使用这个假设是因为 S = 0 肯定是有最优解的，就是和为0需要最少0个硬币。另外一方面，硬币的币值是已知条件。当你想将和增加任意值的时候，必然要尝试所有的硬币。所以状态转移过程中，把每一种硬币循环测试一次，这个过程是不能少的。

在状态转移过程中，有可能添加一个硬币得到最优解；也有可能添加一个硬币，换出一个硬币得到最优解；也有可能添加一个硬币，换出 n 个硬币得到最优解。这些可能的正确性取决于现存的硬币是怎么组成的，也就是说，你至少要知道某一些比 S + N 小的最优解，才能判断新的最优解是哪个。以此类推，可以用 m 个硬币，换出 n 个硬币。

也就是说，在硬币替换过程中，你必须知道每一个比 S + N 小的最优解，才能得到新的最优解。

也就是说，解法框架至少需要每一个硬币和每一个比 S + N 小的最优解做比较，才能确保状态转移。

这个解法是一个通用解法，那在特别的情况下，两层循环有没有剪枝的可能呢？

我们先看和这边，之所以要对比每一个比 S 小的和，是因为这里有个隐含条件，任意硬币是可以组成全部正整数的。那特殊的硬币，比如只有一种，很显然，只能组成这个币值倍数的和。如果这个硬币是1的话，可以组成全部正整数。

两个硬币，比如2和5。可以组成全部正整数吗？也就是说2x+5y是不是可以铺满整个正整数空间。我们用数学归纳法，如果2和5可以组成S，2和5可以组成 S + 1 吗？如果 S 是偶数显然可以，如果 S 是奇数，我们让 S - 5，得到偶数，也可以。所以只要 S 大于5，就可以由5和2组成。

如果是5和7呢，7x7=49，5x10=50，用10个5替换7个7，使得和增加一。也就是说 S 大于50，就可以由5和7组成。

如果是任意整数对呢，这个比较尴尬，我也不会。不过我搜到一个算法，[math.stackexchange.com](https://math.stackexchange.com/questions/690601/find-a-pair-of-integers-x-and-y-such-that-17369x-5472y-4)

~~我还没有仔细看~~ `看完这个算法发现就是计算最大公约数的算法，这个算法没有最后可以得到1的保证。不过经验上来看的话，奇数是可以得到的。`不过这个分析可以先到此打住。从我测试的几对数字来看，应该是可以的，两个整数，如果 S 足够大，一定可以组成。当然互为倍数的可以看做一个数，比如4和8，显然只能组成4的倍数。两个偶数也不能组成奇数和。总的来说剪枝的空间不是很大。

硬币这边币值是固定的，硬币个数剪枝首先就是公倍数替换，比如5个7替换7个5.

另一方面题目的要求也可以变化，比如币值偶数的硬币个数必须为奇数，等等。这个不能算在算法上的改进。

beginner 部分到此就结束了。

## 基础等级

这个问题和上一个问题本质上完全相同，也是一个经典题目叫做“最长非降子序列”。

---

这种典型问题的解题过程很关键的点在于定义问题，状态和转移可以泛化。

## 中等等级

这个问题是一个二维的问题。一个 MxN 方格的表，从左上到右下，一次只能移动一格，右或者下，每个格子里有一定数量的苹果。问从左上角到右下角，怎样拿到苹果最多。

---

二维问题中，保存的数据因为路径多了一个维度，所以数据量是乘法的关系，计算状态转移时，需要对比两个维度的转移。从而达成取得任意一个路径最优值的结果。

在这个方向上提升维度，会导致数据量变多，同时计算过程也需要多个步骤，但是本质上都是把空间中的每一个状态都尝试一次。

本问题和上一个基础等级问题的剪枝空间在于，如果数据有某种特点，那么最长子序列可以用1，2，3去尝试。更长的子序列从之前找到的子序列往后找，有可能速度会更快，取决于最长子序列长度和数据长度的不同。

本问题的剪枝空间在于，挑出最大的 M + N 个苹果的格子，看是否可以组成合法的路径。然后依次替换，从而将一个二维 dp 问题转化为一维的 dp 问题。

在一个典型的 dp 问题中，两层循环，谁先谁后，可能会导致不同的剪枝空间。先升维度的那一边有性能存储的劣势。


## 中高级别

中高级问题是一个 Dijkstra 问题加上每走一步需要付一定的钱，而钱是有限的，找到最短路径，如果有多条，则找到最短同时最便宜的路径。

---

这个问题和上一个升维问题类似，区别在于提升的维度不是同一类。因为维度不同，所以不能同时计算，而必须是计算完成之后，再计算另一个。变体可以用付钱转换成路的长度来变为同一类维度，也可以增加比如油耗来提升维度。

同样的，这类问题我们可以转变循环对象，使用钱数来循环，找出合法路径。将二维 dp 变为一维的 dp 问题。在后面的高级问题中，有可能将两个层面都变成二维，这个优化的思路就失效了。

## 高级等级

高级版问题是中等问题的一个升级，一个表格不是走一趟，而是走一个半来回。题目给的思路是通过一系列变化，问题等同于三条路同时走。

---

这个问题我想的是，将他等同于三个连续表格更好。表格的右下角连接下一个表格的左上角，位置重复。不同于经典的表格问题在于，每走一步，表格中的苹果数目有变化。但是对于 dp 问题来说，后面还没走的路径中的苹果变化不影响最优的结果，所以是一个程序上的处理，走一步需要更新后续表格中的苹果个数。

和前面类似，这个问题也可以转变为一维的 dp 问题。

如果要将这个问题苹果这侧也变为二维，则需要增加规则，表格中的苹果被取走后，会按照一定规则生成新的苹果。这样以来，你取走苹果的时候，也要考虑到后续苹果变化的情况。而不是直接置0

## 尾声

~~这个文章还留了一个尾巴，有个算法叫 Extended Euclidean Algorithm 没有看~~。另外，从基本的 dp 问题之上，也可以构建更为复杂的问题。比如提升维度，以及提升两侧的实体，并且实体之间互相影响。多层的 dp 问题。这些可以后续研究。
